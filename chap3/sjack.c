/* Stackjacking practice
 * http://inaz2.hatenablog.com/entry/2015/03/27/021422
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/uaccess.h>

#include "sjack.h"

static int device_open(struct inode *inode, struct file *file);
static int device_release(struct inode *inode, struct file *file);
static long device_ioctl(struct file *file, unsigned int ioctl_num, unsigned long ioctl_param);

static struct class *class;
static int major_no;

static struct file_operations fops = {
    .open = device_open,
    .release = device_release,
    .unlocked_ioctl = device_ioctl,
};

static int device_open(struct inode *inode, struct file *file)
{
    try_module_get(THIS_MODULE);
    return 0;
}

static int device_release(struct inode *inode, struct file *file)
{
    module_put(THIS_MODULE);
    return 0;
}

static long device_ioctl(struct file *file, unsigned int cmd, unsigned long args)
{
    unsigned long buf[100];
    struct ioctl_sl_arg *sl_arg;
    struct ioctl_aaw_arg *aaw_arg;

    buf[0] = 0;

    switch (cmd) {
    case IOCTL_STACK_LEAK:
        sl_arg = (struct ioctl_sl_arg *)args;
        put_user(buf[sl_arg->index], &sl_arg->value);
        return 0;
    case IOCTL_AAW:
        aaw_arg = (struct ioctl_aaw_arg *)args;
        *(aaw_arg->ptr) = aaw_arg->value;
        return 0;
    }

    return -EINVAL;
}

static int m_init (void)
{
	  major_no = register_chrdev(0, DEVICE_NAME, &fops);
	  class = class_create(THIS_MODULE, DEVICE_NAME);
	  device_create(class, NULL, MKDEV(major_no, 0), NULL, DEVICE_NAME);
    return 0;
}

static void m_exit (void)
{
	device_destroy(class, MKDEV(major_no, 0));
	class_unregister(class);
	class_destroy(class);
	unregister_chrdev(major_no, DEVICE_NAME);
	printk(KERN_INFO "Driver unloaded\n");
}

module_init(m_init);
module_exit(m_exit);
MODULE_LICENSE("GPL");
